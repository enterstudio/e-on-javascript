# Copyright 2008-2009 Kevin Reid, under the terms of the MIT X license
# found at http://www.opensource.org/licenses/mit-license.html ................

pragma.syntax("0.9")
pragma.enable("accumulator")

def compiler := <import:org.erights.eojs.compiler>
def commonEmakerList := <import:org.erights.eojs.commonEmakerList>
def staticSafeEnv := <import:org.erights.eojs.makeStaticSafeEnv>(compiler)
def parse := <elang:syntax.makeEParser>.run
def makeUpdocParser := <import:org.erights.e.tools.updoc.makeUpdocParserAuthor>(null) # XXX support the user supplying a hash-cache for the animation case

def Writer := any
def Term := <import:org.quasiliteral.term.makeTerm>.asType()

def nullWriter {match _ {}}
def nullResolver {match _ {}}

def htmlesc(t :String) {
  return t.replaceAll("&", "&amp;").replaceAll("<", "&lt;").replaceAll(">", "&gt;")
}
def jsQuote(t :String) {
  # XXX should use either jsKit (not accessible outside of the compiler currently) or Term-tree (currently has inaccuracy bugs wrt newlines) to generate real JS rather than relying on similarity of E string syntax
  return E.toQuote(t).replaceAll("\n", "\\n")
}

def compileUpdoc {
  /** The prefix is used for element IDs and JS identifiers.
    * whetherFoundResolver, if provided, is resolved to a boolean indicating whether there were any updoc steps present. */
  to toHTMLFragment(
    prefix :String,
    [=> progress :Writer := nullWriter,
     => whetherFoundResolver := nullResolver],
    updoc :Term
  ) {
    
    def term`script(inVats(@vatNames*),
                    [@sequences*])` := updoc
    
    def steps := switch (sequences) {
      # one vat
      match [term`inVat(@vatName, [@steps*])`] {
        steps
      }
      
      # no vats (empty updoc)
      match [] {
        []
      }
      
      # multiple vats
      match [_, _] + _ {
        # XXX ejector
        throw("Cannot convert multiple-vat Updoc.")
      }
    }
    
    def envVar := `${prefix}_eenv`
    
    whetherFoundResolver.resolve(steps.size().aboveZero())
    
    return `$\
      <script>
        var $envVar = e_makeSafeEnv()
      </script>

      ${ accum "" for i => step in steps { _ + {
        progress.print(".")
        progress.flush()
        def term`test(@source,
                      {@answers*})` := step

        def body := escape syntaxFail {
          def ast := try { parse(source) } catch syntaxError { syntaxFail(syntaxError) }

          var senv := compiler.importEnv(staticSafeEnv, ast.staticScope())
          def js := compiler.assignResult("res", ast, &senv)
          if (js.indexOf1("</") != -1) {
            throw("Shouldn't happen: found </ in generated JS")
          }

          `
            function run_$i() {
              var res;
              ${compiler.import(ast.staticScope(), envVar)}
              $js;
              ${compiler."export"(envVar, envVar, ast.staticScope(), senv)};
              return res;
            }

            function chain_$i() {
              updoc_runStep(${jsQuote(prefix)}, run_$i, $i, ${prefix}_expected_$i)
              setTimeout(chain_${i+1}, 1);
            }
          `
        } catch syntaxError {
          `
            function chain_$i() {
              updoc_runSyntaxError(${jsQuote(prefix)}, ${jsQuote(E.toString(syntaxError))}, $i, ${prefix}_expected_$i)
              setTimeout(chain_${i+1}, 1);
            }
          `
        }
        ` 
          <div class="updoc-step updoc-pending" id="$prefix-step-$i">
          <pre class="updoc-expr">? ${htmlesc(source)}</pre>
          <script>
            var ${prefix}_expected_$i = [${", ".rjoin(
              accum [] for term`@k:@{v :String}` in answers {
                _.with(`[${jsQuote(k.getTag().getTagName())},
                         ${jsQuote(v)}]`)
              }
            )}]

            $body
          </script>
          ${accum "" for answer in answers { _ + {
            def term`@{label :String}: @{text :String}` := answer
            `
            <pre class="updoc-output-exp" id="$prefix-expect-$i"># ${htmlesc(E.toString(label))}: ${htmlesc(E.toString(text))}</pre>
            `
          }}}
          <pre class="updoc-output-got" id="$prefix-output-$i"></pre>
        </div>$\n`
      }}}
      <script>
        function chain_${steps.size()} () {
          // all done!
        }
        setTimeout(chain_0, 1)
      </script>
    `
  }
  /** Convert parsed Updoc into a complete HTML document. "dir" is the relative or absolute URL (with no trailing slash) of the directory in which the EoJS runtime support files are located. */
  to toHTMLDocument(
    dir :String,
    [=> title :String := "E-on-JavaScript converted Updoc"] | options,
    updoc :Term
  ) {
    return `
      <html><head>
        <title>${htmlesc(title)}</title>
        ${compileUpdoc.getHTMLHeadInclusion(dir)}
      </head><body>
        <div id="output"></div>
        <h1>${htmlesc(title)}</h1>
        ${compileUpdoc.toHTMLFragment("upd1", options, updoc)}
      </body></html>
    `
  }
  /** As toHTMLDocument/3, but takes HTML source and produces a HTML document including all the markup of the original, with added Updoc support. (XXX but it doesn't actually do that yet.) */
  to animateHTMLDocument(
    dir :String,
    options :Map,
    htmlSource :Twine
  ) {
    return compileUpdoc.toHTMLDocument(dir, options, makeUpdocParser.parseHtml(htmlSource))
  }
  # XXX the following list of emakers is static, not configurable or computed
  to getHTMLHeadInclusion(dir) { return `$\
    <!-- E runtime -->
    <script src="$dir/e.js"></script>
   
    <!-- Updoc runtime -->
    <script src="$dir/updoc-driver.js"></script>
    <link rel="stylesheet" href="$dir/updoc.css">
   
    <!-- Libraries possibly used by updoc code -->
    ${"\n    ".rjoin(accum "" for emaker in commonEmakerList {
      _.with(`<script src="$dir/import/${emaker.replaceAll(".", "/")}.js"></script>`)
    })}
  `}
  
  /** Create a HTML document which will embed and execute every listed converted-updoc file. */
  to makeUpdocIndexDocument(dir :String, files :List[Tuple[String, any]]) {
    # XXX this page should run each iframe serially or limited parallel, and monitor them for success/failure and summarize the results.
    return `$\
 <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html><head>
  <title>E Specification Tests</title>
  <link rel="stylesheet" href="../serve/updoc.css">
</head><body>

<div class="updoc-pane-group">${accum "" for i => [name, file] in files {
  # XXX URI-encoding
  _ + `<iframe id="updoc-frame-$i" class="updoc-pane" src="${htmlesc(file.getPath())}"><a href="${htmlesc(file.getPath())}">${htmlesc(name)}</a><br></iframe>`
}}</div>

</body>`
    
  }
}